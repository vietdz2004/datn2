const { Review, Product, User, Order, OrderDetail } = require('../models');
const { Op, QueryTypes } = require('sequelize');
const { sequelize } = require('../models/database');

// L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° (admin)
exports.getAll = async (req, res) => {
  try {
    const { search = '', status = '', page = 1, limit = 10 } = req.query;
    const where = {};
    
    // Filter tr·∫°ng th√°i
    if (status) {
      where.trangThai = status;
    }
    
    // Filter search (s·∫£n ph·∫©m, user, n·ªôi dung)
    if (search) {
      where[Op.or] = [
        { noiDung: { [Op.like]: `%${search}%` } },
      ];
    }
    
    // Ph√¢n trang
    const offset = (parseInt(page) - 1) * parseInt(limit);
    
    // Query tr·ª±c ti·∫øp kh√¥ng d√πng associations
    const { count, rows } = await Review.findAndCountAll({
      where,
      order: [['ngayDanhGia', 'DESC']],
      limit: parseInt(limit),
      offset
    });
    
    // Map l·∫°i d·ªØ li·ªáu cho FE (kh√¥ng d√πng associations)
    const data = rows.map(r => ({
      id_Review: r.id_DanhGia,
      productName: `Product #${r.id_SanPham}`, // T·∫°m th·ªùi
      id_SanPham: r.id_SanPham,
      userName: `User #${r.id_NguoiDung}`, // T·∫°m th·ªùi
      id_NguoiDung: r.id_NguoiDung,
      noiDung: r.noiDung,
      sao: r.danhGiaSao,
      ngayTao: r.ngayDanhGia,
      trangThai: r.trangThai || 'active',
      id_DonHang: r.id_DonHang,
      orderStatus: 'Unknown', // T·∫°m th·ªùi
      phanHoiAdmin: r.phanHoiAdmin,
      ngayPhanHoi: r.ngayPhanHoi
    }));
    
    res.json({
      success: true,
      data,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(count / limit),
        totalItems: count,
        itemsPerPage: parseInt(limit)
      }
    });
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
};

// L·∫•y ƒë√°nh gi√° theo id
exports.getById = async (req, res) => {
  try {
    const review = await Review.findByPk(req.params.id, {
      include: [
        { model: Product, attributes: ['id_SanPham', 'tenSp', 'hinhAnh'] },
        { model: User, attributes: ['id_NguoiDung', 'ten', 'email'] },
        { model: Order, attributes: ['id_DonHang', 'trangThaiDonHang', 'ngayDatHang'] }
      ]
    });
    
    if (!review) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë√°nh gi√°' });
    res.json(review);
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
};

// T·∫°o m·ªõi ƒë√°nh gi√° (v·ªõi validation logic m·ªõi)
exports.create = async (req, res) => {
  try {
    const { id_SanPham, id_DonHang, noiDung, danhGiaSao } = req.body;
    const id_NguoiDung = req.user?.id || req.body.id_NguoiDung; // T·ª´ auth middleware
    
    // VALIDATION - Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!id_SanPham || !id_DonHang || !danhGiaSao) {
      return res.status(400).json({
        success: false,
        message: 'Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc: id_SanPham, id_DonHang, danhGiaSao'
      });
    }
    
    if (!id_NguoiDung) {
      return res.status(400).json({
        success: false,
        message: 'Ng∆∞·ªùi d√πng ch∆∞a ƒëƒÉng nh·∫≠p'
      });
    }
    
    // N·ªôi dung kh√¥ng b·∫Øt bu·ªôc, nh∆∞ng n·∫øu c√≥ th√¨ ph·∫£i c√≥ √≠t nh·∫•t 10 k√Ω t·ª±
    if (noiDung && noiDung.trim().length > 0 && noiDung.trim().length < 10) {
      return res.status(400).json({
        success: false,
        message: 'N·ªôi dung ƒë√°nh gi√° ph·∫£i c√≥ √≠t nh·∫•t 10 k√Ω t·ª± ho·∫∑c ƒë·ªÉ tr·ªëng'
      });
    }
    
    if (danhGiaSao < 1 || danhGiaSao > 5) {
      return res.status(400).json({
        success: false,
        message: 'ƒê√°nh gi√° sao ph·∫£i t·ª´ 1-5'
      });
    }
    
    console.log('üìù Creating new review:', { id_SanPham, id_DonHang, id_NguoiDung, noiDung: noiDung.substring(0, 50) + '...', danhGiaSao });
    
    // VALIDATION - Ki·ªÉm tra ƒë∆°n h√†ng t·ªìn t·∫°i v√† thu·ªôc v·ªÅ user
    const order = await Order.findByPk(id_DonHang);
    if (!order) {
      return res.status(400).json({
        success: false,
        message: 'ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i'
      });
    }
    
    if (order.id_NguoiDung !== parseInt(id_NguoiDung)) {
      return res.status(403).json({
        success: false,
        message: 'B·∫°n kh√¥ng c√≥ quy·ªÅn ƒë√°nh gi√° ƒë∆°n h√†ng n√†y'
      });
    }
    
    // VALIDATION - Ki·ªÉm tra ƒë∆°n h√†ng ƒë√£ ho√†n th√†nh
    if (order.trangThaiDonHang !== 'da_giao') {
      return res.status(400).json({
        success: false,
        message: 'Ch·ªâ c√≥ th·ªÉ ƒë√°nh gi√° ƒë∆°n h√†ng ƒë√£ ho√†n th√†nh'
      });
    }
    
    // VALIDATION - Ki·ªÉm tra s·∫£n ph·∫©m c√≥ trong ƒë∆°n h√†ng kh√¥ng
    const orderDetail = await OrderDetail.findOne({
      where: {
        id_DonHang: id_DonHang,
        id_SanPham: id_SanPham
      }
    });
    
    if (!orderDetail) {
      return res.status(400).json({
        success: false,
        message: 'S·∫£n ph·∫©m kh√¥ng c√≥ trong ƒë∆°n h√†ng n√†y'
      });
    }
    
    // VALIDATION - Ki·ªÉm tra ƒë√£ ƒë√°nh gi√° s·∫£n ph·∫©m n√†y trong ƒë∆°n h√†ng n√†y ch∆∞a
    const existingReview = await Review.findOne({
      where: {
        id_SanPham: id_SanPham,
        id_DonHang: id_DonHang,
        id_NguoiDung: id_NguoiDung
      }
    });
    
    if (existingReview) {
      return res.status(400).json({
        success: false,
        message: 'B·∫°n ƒë√£ ƒë√°nh gi√° s·∫£n ph·∫©m n√†y trong ƒë∆°n h√†ng n√†y r·ªìi'
      });
    }
    
    // T·∫°o ƒë√°nh gi√° m·ªõi
    const reviewData = {
      id_SanPham: parseInt(id_SanPham),
      id_DonHang: parseInt(id_DonHang),
      id_NguoiDung: parseInt(id_NguoiDung),
      noiDung: noiDung ? noiDung.trim() : null,
      hinhAnh: req.body.hinhAnh || null,
      danhGiaSao: parseInt(danhGiaSao),
      ngayDanhGia: new Date(),
      trangThai: 'active'
    };
    
    const review = await Review.create(reviewData);
    
    console.log('‚úÖ Review created successfully:', review.id_DanhGia);
    
    res.status(201).json({
      success: true,
      data: review,
      message: 'ƒê√°nh gi√° ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng'
    });
    
  } catch (error) {
    console.error('‚ùå Error creating review:', error);
    res.status(500).json({ 
      success: false,
      message: 'L·ªói server khi t·∫°o ƒë√°nh gi√°', 
      error: error.message 
    });
  }
};

// C·∫≠p nh·∫≠t ƒë√°nh gi√°
exports.update = async (req, res) => {
  try {
    const review = await Review.findByPk(req.params.id);
    if (!review) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë√°nh gi√°' });
    
    // Ch·ªâ cho ph√©p c·∫≠p nh·∫≠t m·ªôt s·ªë tr∆∞·ªùng nh·∫•t ƒë·ªãnh
    const allowedFields = ['noiDung', 'danhGiaSao', 'trangThai'];
    const updateData = {};
    
    allowedFields.forEach(field => {
      if (req.body[field] !== undefined) {
        updateData[field] = req.body[field];
      }
    });
    
    // Validation cho s·ªë sao
    if (updateData.danhGiaSao && (updateData.danhGiaSao < 1 || updateData.danhGiaSao > 5)) {
      return res.status(400).json({
        success: false,
        message: 'ƒê√°nh gi√° sao ph·∫£i t·ª´ 1-5'
      });
    }
    
    // Validation cho n·ªôi dung
    if (updateData.noiDung && updateData.noiDung.trim().length < 10) {
      return res.status(400).json({
        success: false,
        message: 'N·ªôi dung ƒë√°nh gi√° ph·∫£i c√≥ √≠t nh·∫•t 10 k√Ω t·ª±'
      });
    }
    
    await review.update(updateData);
    
    res.json({
      success: true,
      data: review,
      message: 'C·∫≠p nh·∫≠t ƒë√°nh gi√° th√†nh c√¥ng'
    });
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
};

// X√≥a ƒë√°nh gi√° (soft delete)
exports.delete = async (req, res) => {
  try {
    const review = await Review.findByPk(req.params.id);
    if (!review) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë√°nh gi√°' });
    
    // Soft delete - ch·ªâ c·∫≠p nh·∫≠t tr·∫°ng th√°i
    await review.update({ trangThai: 'deleted' });
    
    res.json({
      success: true,
      message: 'ƒê√£ x√≥a ƒë√°nh gi√° th√†nh c√¥ng'
    });
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
};

// L·∫•y ƒë√°nh gi√° theo s·∫£n ph·∫©m (ch·ªâ hi·ªÉn th·ªã active)
exports.getByProduct = async (req, res) => {
  try {
    console.log('DEBUG getByProduct req.params =', req.params);
    // Support both /reviews/product/:productId and /products/:id/reviews (productRoutes uses :id)
    const productId = req.params.productId || req.params.id;
    console.log('üîç Fetching reviews for product:', productId);

    if (!productId) {
      return res.status(400).json({ success: false, message: 'productId is required in params' });
    }

    // L·∫•y reviews theo id_SanPham, ch·ªâ hi·ªÉn th·ªã active
    const reviews = await Review.findAll({
      where: { 
        id_SanPham: productId,
        trangThai: 'active'
      },
      include: [
        { model: User, attributes: ['id_NguoiDung', 'ten'] },
        { model: Order, attributes: ['id_DonHang', 'ngayDatHang'] }
      ],
      order: [['ngayDanhGia', 'DESC']]
    });

    console.log('üìä Found reviews for product:', reviews.length);

    res.json({
      success: true,
      data: reviews,
      message: `T√¨m th·∫•y ${reviews.length} ƒë√°nh gi√° cho s·∫£n ph·∫©m ${productId}`
    });
  } catch (error) {
    console.error('‚ùå Error fetching product reviews:', error);
    res.status(500).json({ 
      success: false,
      message: 'L·ªói server khi l·∫•y ƒë√°nh gi√°', 
      error: error.message
    });
  }
};

// API: G·ª≠i ph·∫£n h·ªìi admin cho ƒë√°nh gi√°
exports.reply = async (req, res) => {
  try {
    const { id } = req.params;
    const { reply } = req.body;
    
    const review = await Review.findByPk(id);
    if (!review) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ƒë√°nh gi√°' });
    
    review.phanHoiAdmin = reply;
    review.ngayPhanHoi = new Date();
    await review.save();
    
    res.json({ 
      success: true, 
      message: 'ƒê√£ g·ª≠i ph·∫£n h·ªìi', 
      data: review 
    });
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
};

// API: L·∫•y danh s√°ch s·∫£n ph·∫©m trong ƒë∆°n h√†ng m√† user c√≥ th·ªÉ ƒë√°nh gi√°
exports.getOrderProductsForReview = async (req, res) => {
  try {
    const { orderId, userId } = req.params;
    
    if (!orderId || !userId) {
      return res.status(400).json({
        success: false,
        message: 'Order ID v√† User ID l√† b·∫Øt bu·ªôc'
      });
    }

    // Query ƒë·ªÉ l·∫•y s·∫£n ph·∫©m trong ƒë∆°n h√†ng m√† user ƒë√£ mua
    const query = `
      SELECT DISTINCT
        p.id_SanPham,
        p.tenSp,
        p.hinhAnh,
        p.gia,
        p.giaKhuyenMai,
        od.soLuongMua,
        (od.soLuongMua * COALESCE(od.donGia, od.giaMua, p.gia)) AS thanhTien,
        o.trangThaiDonHang,
        o.ngayDatHang,
        CASE WHEN r.id_DanhGia IS NOT NULL THEN 1 ELSE 0 END as hasReviewed,
        r.id_DanhGia as reviewId,
        r.danhGiaSao,
        r.noiDung as reviewContent,
        r.ngayDanhGia as reviewDate
      FROM chitietdonhang od
      JOIN sanpham p ON od.id_SanPham = p.id_SanPham
      JOIN donhang o ON od.id_DonHang = o.id_DonHang
      LEFT JOIN danhgia r ON p.id_SanPham = r.id_SanPham AND r.id_DonHang = o.id_DonHang AND r.id_NguoiDung = ?
      WHERE o.id_DonHang = ? 
        AND o.id_NguoiDung = ?
        AND o.trangThaiDonHang = 'da_giao'
      ORDER BY p.tenSp ASC
    `;

    const products = await sequelize.query(query, {
      replacements: [userId, orderId, userId],
      type: QueryTypes.SELECT
    });

    res.json({
      success: true,
      data: products,
      message: `T√¨m th·∫•y ${products.length} s·∫£n ph·∫©m c√≥ th·ªÉ ƒë√°nh gi√° trong ƒë∆°n h√†ng ${orderId}`
    });

  } catch (error) {
    console.error('‚ùå Error getting order products for review:', error);
    res.status(500).json({
      success: false,
      message: 'L·ªói server khi l·∫•y danh s√°ch s·∫£n ph·∫©m ƒë√°nh gi√°',
      error: error.message
    });
  }
};

// API: T·∫°o ƒë√°nh gi√° cho s·∫£n ph·∫©m trong ƒë∆°n h√†ng (v·ªõi validation)
exports.createOrderReview = async (req, res) => {
  try {
    // Ki·ªÉm tra k·∫øt n·ªëi database
    const { sequelize } = require('../models/database');
    await sequelize.authenticate();
    
    const { orderId, productId, userId } = req.params;
    const { noiDung, danhGiaSao } = req.body;
    
    console.log('üîç Debug - Request params:', { orderId, productId, userId });
    console.log('üîç Debug - Request body:', req.body);
    
    // VALIDATION - Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    // N·ªôi dung kh√¥ng b·∫Øt bu·ªôc, nh∆∞ng n·∫øu c√≥ th√¨ ph·∫£i c√≥ √≠t nh·∫•t 10 k√Ω t·ª±
    if (noiDung && noiDung.trim().length > 0 && noiDung.trim().length < 10) {
      return res.status(400).json({
        success: false,
        message: 'N·ªôi dung ƒë√°nh gi√° ph·∫£i c√≥ √≠t nh·∫•t 10 k√Ω t·ª± ho·∫∑c ƒë·ªÉ tr·ªëng'
      });
    }
    
    if (!danhGiaSao || danhGiaSao < 1 || danhGiaSao > 5) {
      return res.status(400).json({
        success: false,
        message: 'ƒê√°nh gi√° sao ph·∫£i t·ª´ 1-5'
      });
    }

    // VALIDATION - Ki·ªÉm tra user ƒë√£ mua s·∫£n ph·∫©m n√†y trong ƒë∆°n h√†ng ch∆∞a
    const purchaseQuery = `
      SELECT COUNT(*) as count
      FROM chitietdonhang od
      JOIN donhang o ON od.id_DonHang = o.id_DonHang
      WHERE o.id_DonHang = ? 
        AND o.id_NguoiDung = ? 
        AND od.id_SanPham = ?
        AND o.trangThaiDonHang = 'da_giao'
    `;

    const [purchaseResult] = await sequelize.query(purchaseQuery, {
      replacements: [orderId, userId, productId],
      type: QueryTypes.SELECT
    });

    if (purchaseResult.count === 0) {
      return res.status(400).json({
        success: false,
        message: 'B·∫°n ch∆∞a mua s·∫£n ph·∫©m n√†y ho·∫∑c ƒë∆°n h√†ng ch∆∞a ho√†n th√†nh'
      });
    }

    // VALIDATION - Ki·ªÉm tra user ƒë√£ ƒë√°nh gi√° s·∫£n ph·∫©m n√†y trong ƒë∆°n h√†ng n√†y ch∆∞a
    const existingReview = await Review.findOne({
      where: {
        id_SanPham: productId,
        id_DonHang: orderId,
        id_NguoiDung: userId
      }
    });

    if (existingReview) {
      return res.status(400).json({
        success: false,
        message: 'B·∫°n ƒë√£ ƒë√°nh gi√° s·∫£n ph·∫©m n√†y trong ƒë∆°n h√†ng n√†y r·ªìi'
      });
    }
    
    console.log('üìù Creating order review:', { orderId, productId, userId, noiDung: noiDung ? noiDung.substring(0, 50) + '...' : 'null', danhGiaSao });
    
    // T·∫°o ƒë√°nh gi√° m·ªõi
    const reviewData = {
      id_SanPham: parseInt(productId),
      id_DonHang: parseInt(orderId),
      id_NguoiDung: parseInt(userId),
      noiDung: noiDung ? noiDung.trim() : null,
      hinhAnh: req.body.hinhAnh || null,
      danhGiaSao: parseInt(danhGiaSao) || 5, // ƒê·∫£m b·∫£o c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh
      ngayDanhGia: new Date(),
      trangThai: 'active'
    };
    
    console.log('üìù Attempting to create review with data:', reviewData);
    
    const review = await Review.create(reviewData);
    
    console.log('‚úÖ Order review created successfully:', review.id_DanhGia);
    
    res.status(201).json({
      success: true,
      data: review,
      message: 'ƒê√°nh gi√° ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng'
    });
    
  } catch (error) {
    console.error('‚ùå Error creating order review:', error);
    
    // Ki·ªÉm tra l·ªói unique constraint
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(400).json({
        success: false,
        message: 'B·∫°n ƒë√£ ƒë√°nh gi√° s·∫£n ph·∫©m n√†y trong ƒë∆°n h√†ng n√†y r·ªìi'
      });
    }
    
    // Ki·ªÉm tra l·ªói validation
    if (error.name === 'SequelizeValidationError') {
      return res.status(400).json({
        success: false,
        message: 'D·ªØ li·ªáu ƒë√°nh gi√° kh√¥ng h·ª£p l·ªá: ' + error.message
      });
    }
    
    res.status(500).json({ 
      success: false,
      message: 'L·ªói server khi t·∫°o ƒë√°nh gi√°', 
      error: error.message 
    });
  }
};

// API: L·∫•y ƒë√°nh gi√° c·ªßa user cho s·∫£n ph·∫©m trong ƒë∆°n h√†ng c·ª• th·ªÉ
exports.getUserProductReview = async (req, res) => {
  try {
    const { productId, userId, orderId } = req.params;
    
    const review = await Review.findOne({
      where: {
        id_SanPham: productId,
        id_NguoiDung: userId,
        id_DonHang: orderId
      }
    });

    res.json({
      success: true,
      data: review,
      message: review ? 'T√¨m th·∫•y ƒë√°nh gi√°' : 'Ch∆∞a c√≥ ƒë√°nh gi√°'
    });

  } catch (error) {
    console.error('‚ùå Error getting user product review:', error);
    res.status(500).json({
      success: false,
      message: 'L·ªói server khi l·∫•y ƒë√°nh gi√°',
      error: error.message
    });
  }
};

// API: L·∫•y t·∫•t c·∫£ ƒë√°nh gi√° c·ªßa user
exports.getUserReviews = async (req, res) => {
  try {
    const { userId } = req.params;
    const { page = 1, limit = 10 } = req.query;
    
    const offset = (parseInt(page) - 1) * parseInt(limit);
    
    const { count, rows } = await Review.findAndCountAll({
      where: { 
        id_NguoiDung: userId,
        trangThai: { [Op.ne]: 'deleted' }
      },
      include: [
        { model: Product, attributes: ['id_SanPham', 'tenSp', 'hinhAnh'] },
        { model: Order, attributes: ['id_DonHang', 'ngayDatHang'] }
      ],
      order: [['ngayDanhGia', 'DESC']],
      limit: parseInt(limit),
      offset
    });
    
    res.json({
      success: true,
      data: rows,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(count / parseInt(limit)),
        totalItems: count,
        itemsPerPage: parseInt(limit)
      },
      message: `T√¨m th·∫•y ${count} ƒë√°nh gi√° c·ªßa ng∆∞·ªùi d√πng`
    });
    
  } catch (error) {
    console.error('‚ùå Error getting user reviews:', error);
    res.status(500).json({
      success: false,
      message: 'L·ªói server khi l·∫•y ƒë√°nh gi√° ng∆∞·ªùi d√πng',
      error: error.message
    });
  }
};

// API: ·∫®n/hi·ªán ƒë√°nh gi√° (admin)
exports.toggleReviewVisibility = async (req, res) => {
  try {
    const { id } = req.params;
    const { trangThai } = req.body;
    
    if (!['active', 'hidden'].includes(trangThai)) {
      return res.status(400).json({
        success: false,
        message: 'Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá'
      });
    }
    
    const review = await Review.findByPk(id);
    if (!review) {
      return res.status(404).json({
        success: false,
        message: 'Kh√¥ng t√¨m th·∫•y ƒë√°nh gi√°'
      });
    }
    
    await review.update({ trangThai });
    
    res.json({
      success: true,
      message: `ƒê√£ ${trangThai === 'hidden' ? '·∫©n' : 'hi·ªÉn th·ªã'} ƒë√°nh gi√° th√†nh c√¥ng`,
      data: { id, trangThai }
    });
    
  } catch (error) {
    console.error('‚ùå Error toggling review visibility:', error);
    res.status(500).json({
      success: false,
      message: 'L·ªói server khi thay ƒë·ªïi tr·∫°ng th√°i ƒë√°nh gi√°',
      error: error.message
    });
  }
};

// API: L·∫•y th·ªëng k√™ ƒë√°nh gi√° cho s·∫£n ph·∫©m
exports.getProductReviewStats = async (req, res) => {
  try {
    const { productId } = req.params;
    
    if (!productId) {
      return res.status(400).json({
        success: false,
        message: 'Product ID l√† b·∫Øt bu·ªôc'
      });
    }

    // Query ƒë·ªÉ l·∫•y th·ªëng k√™ ƒë√°nh gi√°
    const statsQuery = `
      SELECT 
        COUNT(*) as totalReviews,
        AVG(danhGiaSao) as averageRating,
        MIN(danhGiaSao) as minRating,
        MAX(danhGiaSao) as maxRating,
        SUM(CASE WHEN danhGiaSao = 5 THEN 1 ELSE 0 END) as fiveStar,
        SUM(CASE WHEN danhGiaSao = 4 THEN 1 ELSE 0 END) as fourStar,
        SUM(CASE WHEN danhGiaSao = 3 THEN 1 ELSE 0 END) as threeStar,
        SUM(CASE WHEN danhGiaSao = 2 THEN 1 ELSE 0 END) as twoStar,
        SUM(CASE WHEN danhGiaSao = 1 THEN 1 ELSE 0 END) as oneStar
      FROM danhgia 
      WHERE id_SanPham = ? AND trangThai = 'active'
    `;

    const [stats] = await sequelize.query(statsQuery, {
      replacements: [productId],
      type: QueryTypes.SELECT
    });

    // T√≠nh to√°n ph·∫ßn trƒÉm cho m·ªói sao
    const total = parseInt(stats.totalReviews);
    const ratingStats = {
      totalReviews: total,
      averageRating: total > 0 ? parseFloat(stats.averageRating).toFixed(1) : '0.0',
      minRating: parseInt(stats.minRating) || 0,
      maxRating: parseInt(stats.maxRating) || 0,
      ratingDistribution: {
        5: {
          count: parseInt(stats.fiveStar) || 0,
          percentage: total > 0 ? Math.round((parseInt(stats.fiveStar) / total) * 100) : 0
        },
        4: {
          count: parseInt(stats.fourStar) || 0,
          percentage: total > 0 ? Math.round((parseInt(stats.fourStar) / total) * 100) : 0
        },
        3: {
          count: parseInt(stats.threeStar) || 0,
          percentage: total > 0 ? Math.round((parseInt(stats.threeStar) / total) * 100) : 0
        },
        2: {
          count: parseInt(stats.twoStar) || 0,
          percentage: total > 0 ? Math.round((parseInt(stats.twoStar) / total) * 100) : 0
        },
        1: {
          count: parseInt(stats.oneStar) || 0,
          percentage: total > 0 ? Math.round((parseInt(stats.oneStar) / total) * 100) : 0
        }
      }
    };

    res.json({
      success: true,
      data: ratingStats,
      message: `Th·ªëng k√™ ƒë√°nh gi√° cho s·∫£n ph·∫©m ${productId}`
    });

  } catch (error) {
    console.error('‚ùå Error getting product review stats:', error);
    res.status(500).json({
      success: false,
      message: 'L·ªói server khi l·∫•y th·ªëng k√™ ƒë√°nh gi√°',
      error: error.message
    });
  }
};